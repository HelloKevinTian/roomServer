'use strict';
/**
 * @tcp网络模块
 * @author tw
 */
var net = require('net');
var util = require('util');
var domain = require('domain');
var EventEmitter = require('events').EventEmitter;
var logger = require('ss-logger').getLogger(__filename);
var ExBuffer = require('ExBuffer');
var Handler = require('ss-handler');

var protoJson = require('../../../cfg/c2s_proto');

/**
 * 网络连接器
 * @extends EventEmitter
 */
var Connector = function() {
	EventEmitter.call(this);

	this.name = null; //服务器名
	this.type = null; //服务器类型
	this.host = ''; //服务器IP
	this.port = 0; //监听端口
	this.timeout = 0; //socket超时时间
	this.isBigEndian = null; //传输数据是否为大端序
	this.use_json = true; //传输格式是否使用json

	this.handler = null; //模块句柄
	this.server = null; //服务器实例
	this.verifyMsg = null; //通讯数据包校验
	this.connection = null; //socket连接时触发模块
	this.disconnect = null; //socket出错时触发模块
};

util.inherits(Connector, EventEmitter);

/**
 * 配置服务器相关
 *
 * @param {String} config 配置文件路径
 */
Connector.prototype.configure = function(type, config) {
	if (type === 'server') {
		this.name = config.name;
		this.type = config.type;
		this.host = config.host;
		this.port = config.port;
		this.timeout = config.timeout;
		this.isBigEndian = config.big_endian;
		this.use_json = config.use_json;

		if (config.hasOwnProperty('verifyMsg')) {
			this.verifyMsg = require(process.cwd() + config.verifyMsg).handle;
		}
		if (config.hasOwnProperty('connection')) {
			this.connection = require(process.cwd() + config.connection).handle;
		}
		if (config.hasOwnProperty('disconnect')) {
			this.disconnect = require(process.cwd() + config.disconnect).handle;
		}
	} else if (type === 'handle') {
		this.handler = new Handler(config);
	}
};

/**
 * 创建 tcp 服务器
 */
Connector.prototype.createTcpServer = function() {
	var self = this;

	self.server = net.createServer();

	self.online();
	self.onErr();

	self.server.listen(self.port, self.host, function() {
		// logger.info('创建 tcp 服务器 host = [%s] port = [%d]', self.server.address().address, self.server.address().port);
	});

	self.server.on('connection', function(sock) {
		var d = domain.create();

		var socketId = sock.remoteAddress + ':' + sock.remotePort;

		sock.test = function() {
			logger.info('socket info：', sock.remoteAddress, sock.remotePort);
		}

		sock.sendMessage = function(data) {
			if (typeof data !== 'string') {
				data = JSON.stringify(data);
			}

			var len = Buffer.byteLength(data);

			//写入4个字节表示本次包长
			var headBuf = new Buffer(4);
			headBuf.writeUInt32LE(len, 0);
			sock.write(headBuf);

			var bodyBuf = new Buffer(len);
			bodyBuf.write(data);
			sock.write(bodyBuf);

			logger.info('<<<<<< 发到客户端的数据:', socketId, (4 + len), data);
		}

		sock.sendError = function(err) {
			var code = Number(err);
			if (isNaN(code) || err == null || err == undefined) {
				code = 10000;
			}

			sock.sendMessage({
				'op': 's2c_error',
				'code': code
			});
		}

		if (self.connection) {
			self.connection(sock);
		};

		onSocketErr();
		onTimeout();
		onException();
		onReceive();

		//回调中异常处理
		function onException() {
			d.on('error', function(err) {
				logger.error('捕获到异常信息：' + err.stack);
				//通知客户端出错
				sock.end();
			});
			d.add(sock);
		}

		//接收客户端数据
		function onReceive() {
			var exBuffer = new ExBuffer().uint32Head().littleEndian();
			if (self.isBigEndian) {
				exBuffer = new ExBuffer().uint32Head()
			}

			//socket接收的原始数据
			sock.on('data', function(data) {
				// logger.info('>>>>> 收到原始数据：', data.length, data.toString());
				exBuffer.put(data);
			});

			//exBuffer分包处理后的数据
			exBuffer.on('data', function(buffer) {
				var args = null;
				if (self.use_json) {
					try {
						args = JSON.parse(buffer.toString());
					} catch (e) {
						args = buffer.toString();
					}
				} else {
					args = buffer.toString();
				}

				logger.info('>>>>> 收到客户端数据：', socketId, buffer.length, args);

				d.run(function() {
					self.socketMessage(sock, args);
				});
			});
		}

		//socket超时处理
		function onTimeout() {
			sock.setTimeout(self.timeout * 1000);
			sock.addListener('timeout', function() {
				logger.debug('>>>>> socket timeout: ip:' + sock.remoteAddress + ', port:' + sock.remotePort);
				sock.emit('c_close');
			});
		}

		//socket错误监听
		function onSocketErr() {
			sock.on('error', function(e) {
				logger.error('>>>>> socket err: ' + e);
				sock.emit('c_close');
			});

			sock.on('close', function(had_error) {
				logger.debug('>>>>> socket on close: ', had_error);
				if (self.disconnect) {
					self.disconnect(sock, had_error);
				}
				if (!sock.destroyed) {
					sock.destroy();
				}
			});

			//新加事件，socket出错时调用 sock.emit('c_close')
			sock.on('c_close', function() {
				logger.debug('>>>>> socket on c_close');
				sock.end();
				sock.destroy();
			});
		}

	});

};

/**
 * 数据协议解析
 *
 * @param {Object} socket
 * @param {Object} args 数据包
 */
Connector.prototype.socketMessage = function(socket, args) {
	try {
		var self = this;
		if (!args) {
			args = {};
		}

		self.verifyMessage(args, function(result, data) {
			if (result) {
				return logger.error('[ %s-Server ] 数据验证未通过!', self.name);
			}

			//-------------------消息格式验证----------------------
			if (!args.op || typeof args.op !== 'string' || !protoJson.hasOwnProperty(args.op)) {
				return logger.error('收到未知请求：', args);
			}
			var msgProto = protoJson[args.op];
			for (var k in msgProto) {
				if (!args.hasOwnProperty(k)) {
					return logger.error('消息字段缺失：', args);
				}
				if (typeof args[k] !== typeof msgProto[k]) {
					return logger.error('消息字段类型不符：', args);
				}
			}
			//-------------------消息格式验证----------------------

			if (self.handler) {
				self.handler.trigger(args.op, data, socket);
			} else {
				logger.error('[ %s-Server ]收到未知请求 data[ %s ]', self.name, JSON.stringify(data));
			}
		}, socket);
	} catch (e) {
		logger.error('try parseMessage %s', e);
	}
};

/**
 * 数据验证
 *
 * @param {Object} args 数据包
 * @param {Function} endcb 结束回调函数
 */
Connector.prototype.verifyMessage = function(args, result, socket) {
	if (this.verifyMsg) {
		this.verifyMsg(args, result, socket);
	} else {
		result(false, args);
	}
};

/**
 * 开启服务器
 */
Connector.prototype.start = function() {
	if (this.type === 'tcp') {
		this.createTcpServer();
	} else {
		logger.error('开启服务器 类型错误! this.type = [ %s ]', this.type);
	}
};

/**
 * 显示服务器信息
 */
Connector.prototype.show = function() {
	logger.info('创建 %s 服务器 host = [%s] port = [%d]', this.type, this.host, this.port);
};

/**
 * 显示服务器配置
 */
Connector.prototype.info = function() {
	logger.info(this);
};

/**
 * 定时器监测客户端连接数量
 */
Connector.prototype.online = function() {
	var self = this;
	setInterval(function() {
		self.server.getConnections(function(err, count) {
			if (!err) {
				logger.info('当前在线人数：' + count);
			}
		})
	}, 30 * 60 * 1000);
}

/**
 * 监听服务器报错
 */
Connector.prototype.onErr = function() {
	var self = this;
	self.server.on('error', function(e) {
		logger.error('WARNING: catch server error: ', e.code);
	});

	self.server.on('close', function() {
		logger.error('WARNING: server closed');
	});
}

/**
 * 限制客户端连接数量
 */
Connector.prototype.limitClientNum = function(n) {
	this.server.maxConnections = n;
}

/**
 * 踢人
 */
Connector.prototype.kick = function(sock) {
	sock.emit('c_close');
}

module.exports = Connector;